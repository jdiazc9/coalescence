###      > wells <- metadata[((metadata$Comm1 == champ1 & metadata$Comm2 == champ2) |
###                          (metadata$Comm1 == champ2 & metadata$Comm2 == champ1)) &
###                          metadata$StabilizingCarb1 == cs &
###                          metadata$StabilizingCarb2 == cs &
###                          metadata$Carbon == cs
###                          ,]
###      > fraction <- otus[,wells$Sample,drop=FALSE]
###      > View(fraction)
###      we again see that some reads match sequences 1 (shared by both isolate_3 and
###      isolate_2), 4, 5, 10 and 13 (unique to isolate_3).
###      This could be because:
###         a) Isolate 3 has 14 copies of the 16S rRNA gene, out of which 12 match sequence
###            4 (12/14 = 0.86), another one matches sequence 1 (1/14 = 0.07) and another
###            one matches sequence 10 (1/14 = 0.07). This feels unlikely.
###         b) Isolate 3 has all copies of the 16S rRNA gene matching to sequence 4, but
###            some mutations arised in some individuals of certain samples. This is
###            unlikely given that sequences 1, 5, 10 and 13 are not a result of point,
###            single base mutations of sequence 4.
###         c) Whatever other reason (contamination...)
###      Whatever the true reason, the safest option is to just consider that isolate 3 maps
###      directly and unequivocally to sequence 4. This sequence is not shared by any other
###      isolate, and this choice ensures that, if a sample that is supposed to contain
###      isolate_3 shows no reads mapping to sequences 1, 5, 10 or 13 (but does show reads
###      mapping to sequence 4), the deconvolution process will not result in a measurement
###      of zero abundance of isolate_3.
# clean sequence mapping table
isolates_esv[isolates_esv <= 0.1] <- 0
isolates_esv[isolates_esv[,'isolate_3'] < 0.5,'isolate_3'] <- 0
isolates_esv <- isolates_esv/matrix(rep(colSums(isolates_esv),nrow(isolates_esv)),
nrow=nrow(isolates_esv),
byrow=TRUE)
# round to 2 digits while maintaining normalization
for (i in 1:ncol(isolates_esv)) {
isolates_esv[,i] <- smart_round(100*isolates_esv[,i])/100
}
# split groups by carbon source
isolates_groups <- list(Glutamine = isolates_groups[grepl('Glutamine',isolates_groups)],
Citrate = isolates_groups[grepl('Citrate',isolates_groups)])
for (cs in carbon_sources) {
isolates_groups[[cs]] <- lapply(isolates_groups[[cs]],
function(x) gsub(paste(cs,'-',sep=''),'',x[grepl(cs,x)]))
}
# structure variable for isolates
isolate_names <- colnames(isolates_esv)
isolates <- list(seq=isolates_esv,
groups=isolates_groups)
### ----------------------------------------------------------------------
### MATCH ISOLATES AND COMMUNITY DOMINANTS
### ----------------------------------------------------------------------
### The question here is, are we sure that the isolate obtained from each
### community is, indeed, the dominant (most abundant) species of that
### community?
### To answer it, we will cross the sequencing data of the whole
### communities with the information we just retrieved from the isolates.
### We will calculate the relative abundance of the isolate in the
### community, assuming that all the reads that match the sequence of the
### isolate come, indeed, from the isolate (in the most general case, some
### or all of those reads could come from different species that share the
### same sequence in at least some of its copies of the 16S, so this
### relative abundance should be taken as the maximum potential relative
### abundance of the isolate in the community).
### All of this is assuming that the same number of reads per individual
### are produced when sequencing. This need not be the case, as different
### species may carry different copy numbers of their 16S rRNA gene. So
### in practice, this approach only serves us to detect extreme cases
### (e.g., the isolate is present in the community only in a very minor
### abundance).
# initialize plotting table
plot_this <- data.frame(carbon_source = character(0),
community = character(0),
sample = character(0),
isolate = character(0),
max_rel_abundance = character(0),
is_isolate = logical(0))
# run through all carbon sources, communities and samples
for (cs in carbon_sources) {
for (comm in community_names) {
for (sample in colnames(communities[[cs]][[comm]])) {
# community composition array
cc <- as.matrix(communities[[cs]][[comm]][,sample,drop=FALSE])
# matrix to map species relative abundance to ESV relative abundance
Q <- as.matrix(isolates[['seq']])
# keep only ESVs with abundance over 0 in either the community or the matrix
n <- rowSums(Q)>0 | cc>0
Q <- Q[n,,drop=FALSE]
cc <- cc[n,,drop=FALSE]
# for every isolate...
for (iso in isolate_names) {
# maximum potential abundance of the isolate in the community
max_rel_abundance <- min(cc/Q[,iso],na.rm=TRUE)
# is this the isolate that was obtained from this community?
is_isolate <- comm %in% isolates[['groups']][[cs]][[iso]]
# add info to plotting table
plot_this <- rbind(plot_this,
data.frame(carbon_source = cs,
community = comm,
sample = sample,
isolate = iso,
max_rel_abundance = max_rel_abundance,
is_isolate = is_isolate))
}
}
}
}
# factors
plot_this$carbon_source <- factor(plot_this$carbon_source,levels=carbon_sources)
plot_this$community <- factor(plot_this$community,levels=community_names)
plot_this$sample <- factor(plot_this$sample,levels=sample_names)
plot_this$isolate <- factor(plot_this$isolate,levels=isolate_names)
plot_this$is_isolate <- factor(plot_this$is_isolate,levels=c(TRUE,FALSE))
# colors (for is_isolate = TRUE or FALSE)
pl_iso <- c('#ca0020','#404040')
# plot relative abundances
myplots[['isolates-abundance-in-communities']] <-
ggplot(data=plot_this,
aes(x=isolate,y=max_rel_abundance,fill=is_isolate)) +
geom_bar(stat="identity",width=1,color='black') +
facet_nested(community ~ carbon_source + sample,
labeller=labeller(community=setNames(gsub('Community','Community ',community_names),
community_names))) +
scale_x_discrete(name='Isolate #',
breaks=isolate_names,
labels=gsub('isolate_','',isolate_names),
expand=expansion(add=1)) +
scale_y_continuous(name='Max. relative abundance\nof isolate in community') +
theme_bw() +
scale_fill_manual(values=pl_iso,
name='Isolate obtained\nfrom community?',
labels=c('Yes','No')) +
theme(text=element_text(size=15))
# display and/or save plot
if (display_plots) {
print(myplots[['isolates-abundance-in-communities']])
}
if (save_plots) {
ggsave(file.path('.','plots','isolates-abundance-in-communities.pdf'),
plot=myplots[['isolates-abundance-in-communities']],
device='pdf',
height=270,
width=300,
units='mm')
}
### Our criterion will be so that we mantain maximum consistency with the experimental
### protocol. We need to consider that a) the dominants at the moment when the plating
### and isolation was done (transfer 12) may have decreased in abundance after 7
### additional transfers and b) species may carry different copy number of the 16s rRNA
### gene so ESV abundance may not perfectly match species abundance. Therefore, we will
### consider a species to be the dominant of a community if it was isolated from it and is
### still at a significant abundance after the 7 additional transfers (i.e. is visible in
### the plot). If the isolate is not visible, we will exclude the corresponding community
### from downstream analysis. From examining the plot:
### Glutamine:
###    - isolate_1 is compatible with being the dominant of Community 1 and it was
###      isolated from that community.
###    - isolate_2 is compatible with being the dominant of Community 2 and it was
###      isolated from that community.
###    - isolate_3 is compatible with being the dominant of Community 3, but isolate_2
###      is also compatible depending on the sample. Because isolate_3 was isolated
###      directly from Community 3, we will consider it as the dominant.
###    - isolate_4 is compatible with being the dominant of Community 4 and it was
###      isolated from that community.
###    - None of the isolates is really compatible with being dominant in Community 5
###      (all relative abundances below ~0.2 when pie plots show an ESV with frequency
###      ~60% in the community).
###    - isolate_4 is compatible with being the dominant of Community 6. isolate_2
###      could also be compatible but it is consistently in a slightly lower abundance
###      across all samples. isolate_4 was also isolated from Community 4 (and appears
###      to really be the dominant). These two communities share the same dominant.
###    - isolate_5 is compatible with being the dominant of Community 7 and it was
###      isolated from that community.
###    - isolate_5 is compatible with being the dominant of Community 8, but isolate_2
###      is also compatible depending on the sample. Because isolate_5 was isolated
###      directly from Community 8, we will consider it as the dominant. Communities
###      7 and 8 share the same dominant.
###
### Citrate:
###    - isolate_2 seems to clearly be the dominant of Community 1, even though
###      isolate_6 was the one obtained from this community. We will consider
###      isolate_2 to be the dominant of this community.
###    - isolate_7 is compatible with being the dominant of Community 2, but isolate_2
###      also is. Because isolate_7 was directly obtained from Community 2, we will
###      consider it the dominant of this community.
###    - isolate_2 is compatible with being the dominant of Community 3 and it was
###      isolated from that community. Communities 1 and 3 share the same dominant.
###    - isolate_2 seems to clearly be the dominant of Community 4, even though
###      isolate_8 was the one obtained from this community. isolate_8 is also at a
###      relatively high fraction. (*)
###    - isolate_2 is compatible with being the dominant of Community 5 and it was
###      isolated from that community. Communities 1, 3 and 5 share the same
###      dominant.
###    - isolate_2 is compatible with being the dominant of Community 6. isolate_9 was
###      isolated from this community but does not appear to be at significant
###      abundance. We will consider isolate_2 to be the dominant of this community.
###      Communities 1, 3, 5 and 6 share the same dominant.
###    - isolate_7 is compatible with being the dominant of Community 7 and it was
###      isolated from that community. Communities 2 and 7 share the same dominant.
###    - isolate_2 is compatible with being the dominant of Community 8. isolate_4
###      could also be compatible but it is consistently in a slightly lower abundance
###      across all samples. Neither of these two isolates were isolated from this
###      community. We will consider isolate_2 to be the dominant. Communities 1, 3,
###      5, 6 and 8 share the same dominant.
# dominants
dominants <- vector(mode='list',length=2)
names(dominants) <- carbon_sources
dominants[['Glutamine']] <- list(isolate_1 = 'Community1',
isolate_2 = 'Community2',
isolate_3 = 'Community3',
isolate_4 = c('Community4','Community6'),
isolate_5 = c('Community7','Community8'),
other = 'Community5')
dominants[['Citrate']] <- list(isolate_2 = c('Community3','Community5'),
isolate_6 = 'Community1',
isolate_7 = c('Community2','Community7'),
isolate_8 = 'Community4',
other = c('Community6','Community8'))
### ----------------------------------------------------------------------
### PAIRWISE COMPETITION VS. COALESCENCE VS. DOMINANT INVADING ALONE
### ----------------------------------------------------------------------
# intialize plotting table
plot_this <- data.frame(carbon_source = character(0),
community_1 = character(0),
community_2 = character(0),
isolate_1 = character(0),
isolate_2 = character(0),
plate_pairwise = character(0),
well_pairwise = character(0),
f_pairwise = numeric(0),
plate_coalescence = character(0),
well_coalescence = character(0),
q_bray_curtis = numeric(0),
q_jensen_shannon = numeric(0),
q_jaccard = numeric(0),
q_endemic = numeric(0),
q_bray_curtis_cohort = numeric(0),
q_jensen_shannon_cohort = numeric(0),
q_jaccard_cohort = numeric(0),
q_endemic_cohort = numeric(0),
f_singleinv = numeric(0))
# run through carbon sources and communities
for (cs in carbon_sources) {
for (i in 1:(length(community_names)-1)) {
for (j in (i+1):length(community_names)) {
#cs <- 'Glutamine'
#i <- 2
#j <- 4
# communities
comm_1 <- community_names[i] # by convention, community 1 will be the invasive and 2 the resident
comm_2 <- community_names[j]
# dominants of the communities
dom_1 <- names(dominants[[cs]])[grep(comm_1,dominants[[cs]])]
dom_2 <- names(dominants[[cs]])[grep(comm_2,dominants[[cs]])]
# proceed only if the dominants of both communities are defined and different
if (dom_1 != dom_2 & dom_1 != 'other' & dom_2 != 'other') {
# find wells of pairwise competition
champ_1 <- gsub('Community','Champion',comm_1)
champ_2 <- gsub('Community','Champion',comm_2)
wells_pairwise <- metadata[((metadata$Comm1 == champ_1 & metadata$Comm2 == champ_2) | (metadata$Comm1 == champ_2 & metadata$Comm2 == champ_1)) &
metadata$Carbon == cs
,]
# composition of pairwise competition wells
cc_pairwise <- otus[,wells_pairwise$Sample,drop=F]
# deconvolution matrix (isolates-to-ESVs map)
Q = isolates[['seq']][,c(dom_1,dom_2)]
# fraction of dominant 1 (invasive) in pairwise competition
f_pairwise <- rep(NA,ncol(cc_pairwise))
for (k in 1:ncol(cc_pairwise)) {
doms_abundance_pairwise <- species_composition_from_sequencing(Q,cc_pairwise[,k,drop=FALSE])
doms_abundance_pairwise <- doms_abundance_pairwise[c(dom_1,dom_2),]
doms_abundance_pairwise <- doms_abundance_pairwise/sum(doms_abundance_pairwise)
f_pairwise[k] <- doms_abundance_pairwise[dom_1]
}
# find all instances of community coalescence
wells_coalescence <- metadata[((metadata$Comm1 == comm_1 & metadata$Comm2 == comm_2) | (metadata$Comm1 == comm_2 & metadata$Comm2 == comm_1)) &
metadata$StabilizingCarb1 == cs &
metadata$StabilizingCarb2 == cs &
metadata$Carbon == cs
,]
# composition of coalesced community
cc_coalesced <- otus[,wells_coalescence$Sample,drop=F]
rownames(cc_coalesced) <- otus$seq_id
# composition of invasive and resident comunnities (average across replicates)
cc_invasive <- as.data.frame(rowMeans(communities[[cs]][[comm_1]]))
cc_resident <- as.data.frame(rowMeans(communities[[cs]][[comm_2]]))
# compositions of community cohorts (dominants removed)
cc_coalesced_cohort <- cc_coalesced
n <- rownames(Q)[Q[,dom_1] > 0]
cc_invasive_cohort <- cc_invasive
cc_invasive_cohort[n,] <- 0
cc_coalesced_cohort[n,] <- 0
n <- rownames(Q)[Q[,dom_2] > 0]
cc_resident_cohort <- cc_resident
cc_resident_cohort[n,] <- 0
cc_coalesced_cohort[n,] <- 0
# re-normalize cohort compositions
cc_invasive_cohort <- cc_invasive_cohort/matrix(rep(colSums(cc_invasive_cohort),nrow(cc_invasive_cohort)),
nrow=nrow(cc_invasive_cohort),
byrow=TRUE)
cc_resident_cohort <- cc_resident_cohort/matrix(rep(colSums(cc_resident_cohort),nrow(cc_resident_cohort)),
nrow=nrow(cc_resident_cohort),
byrow=TRUE)
cc_coalesced_cohort <- cc_coalesced_cohort/matrix(rep(colSums(cc_coalesced_cohort),nrow(cc_coalesced_cohort)),
nrow=nrow(cc_coalesced_cohort),
byrow=TRUE)
# relative similarity invasive-to-coalesced (bray_curtis)
sim_invasive <- cc_similarity(cc_invasive,cc_coalesced,metric='bray_curtis')
sim_resident <- cc_similarity(cc_resident,cc_coalesced,metric='bray_curtis')
q_bray_curtis <- sim_invasive/(sim_invasive + sim_resident)
# relative similarity invasive-to-coalesced (jaccard)
sim_invasive <- cc_similarity(cc_invasive,cc_coalesced,metric='jaccard')
sim_resident <- cc_similarity(cc_resident,cc_coalesced,metric='jaccard')
q_jaccard <- sim_invasive/(sim_invasive + sim_resident)
# relative similarity invasive-to-coalesced (jensen_shannon)
sim_invasive <- cc_similarity(cc_invasive,cc_coalesced,metric='jensen_shannon')
sim_resident <- cc_similarity(cc_resident,cc_coalesced,metric='jensen_shannon')
q_jensen_shannon <- sim_invasive/(sim_invasive + sim_resident)
# relative similarity invasive-to-coalesced (endemic species)
q_endemic <- rep(NA,ncol(cc_coalesced))
for (k in 1:ncol(cc_coalesced)) {
q_endemic[k] <- endemic(cc_invasive,cc_resident,cc_coalesced[,k])
}
# relative similarity invasive-to-coalesced (bray_curtis, cohorts)
sim_invasive <- cc_similarity(cc_invasive_cohort,cc_coalesced_cohort,metric='bray_curtis')
sim_resident <- cc_similarity(cc_resident_cohort,cc_coalesced_cohort,metric='bray_curtis')
q_bray_curtis_cohort <- sim_invasive/(sim_invasive + sim_resident)
# relative similarity invasive-to-coalesced (jaccard, cohorts)
sim_invasive <- cc_similarity(cc_invasive_cohort,cc_coalesced_cohort,metric='jaccard')
sim_resident <- cc_similarity(cc_resident_cohort,cc_coalesced_cohort,metric='jaccard')
q_jaccard_cohort <- sim_invasive/(sim_invasive + sim_resident)
# relative similarity invasive-to-coalesced (jensen_shannon, cohorts)
sim_invasive <- cc_similarity(cc_invasive_cohort,cc_coalesced_cohort,metric='jensen_shannon')
sim_resident <- cc_similarity(cc_resident_cohort,cc_coalesced_cohort,metric='jensen_shannon')
q_jensen_shannon_cohort <- sim_invasive/(sim_invasive + sim_resident)
# relative similarity invasive-to-coalesced (endemic species, cohorts)
q_endemic_cohort <- rep(NA,ncol(cc_coalesced_cohort))
for (k in 1:ncol(cc_coalesced_cohort)) {
q_endemic_cohort[k] <- endemic(cc_invasive_cohort,cc_resident_cohort,cc_coalesced_cohort[,k])
}
# frequency of invasive dominant invading resident community alone
wells_singleinv <- metadata[((metadata$Comm1 == champ_1 & metadata$Comm2 == comm_2) | (metadata$Comm1 == comm_2 & metadata$Comm2 == champ_1)) &
metadata$Carbon == cs
,]
cc_singleinv <- otus[,wells_singleinv$Sample,drop=F]
# invasive dominant ESV composition
Q = isolates[['seq']]
# fraction of dominant 1 (invasive) invading resident community alone
f_singleinv <- rep(NA,ncol(cc_singleinv))
for (k in 1:ncol(cc_singleinv)) {
doms_abundance_singleinv <- species_composition_from_sequencing(Q,cc_singleinv[,k,drop=FALSE])
f_singleinv[k] <- doms_abundance_singleinv[dom_1,]
}
# add to plotting table
plot_this <- rbind(plot_this,
data.frame(
carbon_source = cs,
community_1 = comm_1,
community_2 = comm_2,
isolate_1 = dom_1,
isolate_2 = dom_2,
plate_pairwise = wells_pairwise$Experiment,
well_pairwise = wells_pairwise$Well,
f_pairwise = f_pairwise,
plate_coalescence = wells_coalescence$Experiment,
well_coalescence = wells_coalescence$Well,
q_bray_curtis = q_bray_curtis,
q_jensen_shannon = q_jensen_shannon,
q_jaccard = q_jaccard,
q_endemic = q_endemic,
q_bray_curtis_cohort = q_bray_curtis_cohort,
q_jensen_shannon_cohort = q_jensen_shannon_cohort,
q_jaccard_cohort = q_jaccard_cohort,
q_endemic_cohort = q_endemic_cohort,
f_singleinv = f_singleinv
))
}
}
}
}
# check that sample positioning in wells is consistent
stopifnot(all(plot_this$well_pairwise == plot_this$well_coalescence))
# reshape plotting table (this makes it easier to create multipanel plots)
plot_this <- gather(plot_this,metric,value,q_bray_curtis:q_endemic_cohort)
# characters as factors
plot_this$carbon_source <- factor(plot_this$carbon_source,levels=c('Glutamine','Citrate'))
plot_this$community_1 <- factor(plot_this$community_1,levels=community_names)
plot_this$community_2 <- factor(plot_this$community_2,levels=community_names)
plot_this$metric <- factor(plot_this$metric,levels=unique(plot_this$metric))
# make plots
myplots[['q-vs-pairwise_bray-curtis']] <-
ggplot(data=plot_this[plot_this$metric=='q_bray_curtis',],
aes(x=f_pairwise,y=value,
color=carbon_source)) +
geom_point(size=2) +
geom_smooth(formula = y ~ x,
method = 'lm',
se = FALSE) +
scale_y_continuous(name='Q\nCoalesced - Invasive',
limits=c(0,1),
breaks=c(0,0.5,1),
labels=c('0','0.5','1')) +
scale_x_continuous(name='Frequency of invasive dominant species\nin pairwise competition',
limits=c(0,1),
breaks=c(0,0.5,1),
labels=c('0','0.5','1')) +
scale_color_manual(values=pl_carbon) +
theme_bw() +
theme(panel.grid=element_blank(),
legend.title=element_blank(),
legend.position=c(0.2,0.9),
legend.background=element_rect(fill='transparent'),
text=element_text(size=15),
axis.text=element_text(size=15),) +
coord_fixed() +
ggtitle('Bray-Curtis similarity')
myplots[['q-vs-pairwise_other-metrics']] <-
ggplot(data=plot_this[plot_this$metric!='q_bray_curtis' & !grepl('cohort',plot_this$metric),],
aes(x=f_pairwise,y=value,
color=carbon_source)) +
geom_point(size=2) +
geom_smooth(formula = y ~ x,
method = 'lm',
se = FALSE) +
facet_grid(~ metric,
labeller=labeller(metric=setNames(c('Jaccard similarity',
'Jensen-Shannon similarity\n(1 - distance)',
'Endemic species overlap'),
c('q_jaccard',
'q_jensen_shannon',
'q_endemic')))) +
scale_y_continuous(name='Q\nCoalesced - Invasive',
limits=c(0,1),
breaks=c(0,0.5,1),
labels=c('0','0.5','1')) +
scale_x_continuous(name='Frequency of invasive dominant species\nin pairwise competition',
limits=c(0,1),
breaks=c(0,0.5,1),
labels=c('0','0.5','1')) +
scale_color_manual(values=pl_carbon) +
theme_bw() +
theme(panel.grid=element_blank(),
legend.title=element_blank(),
legend.background=element_rect(fill='transparent'),
text=element_text(size=15),
axis.text=element_text(size=15),
strip.text=element_text(hjust=-0.01,
vjust=-0.01),
strip.background=element_rect(fill='transparent',
color='transparent')) +
coord_fixed()
myplots[['q-vs-pairwise_cohorts']] <-
ggplot(data=plot_this[grepl('cohort',plot_this$metric),],
aes(x=f_pairwise,y=value,
color=carbon_source)) +
geom_point(size=2) +
geom_smooth(formula = y ~ x,
method = 'lm',
se = FALSE) +
facet_wrap(~ metric,
nrow=2,
labeller=labeller(metric=setNames(c('Bray-Curtis similarity',
'Jaccard similarity',
'Jensen-Shannon similarity\n(1 - distance)',
'Endemic species overlap'),
c('q_bray_curtis_cohort',
'q_jaccard_cohort',
'q_jensen_shannon_cohort',
'q_endemic_cohort')))) +
scale_y_continuous(name='Q\nCoalesced - Invasive',
limits=c(0,1),
breaks=c(0,0.5,1),
labels=c('0','0.5','1')) +
scale_x_continuous(name='Frequency of invasive dominant species\nin pairwise competition',
limits=c(0,1),
breaks=c(0,0.5,1),
labels=c('0','0.5','1')) +
scale_color_manual(values=pl_carbon) +
theme_bw() +
theme(panel.grid=element_blank(),
legend.title=element_blank(),
legend.background=element_rect(fill='transparent'),
text=element_text(size=15),
axis.text=element_text(size=15),
strip.text=element_text(hjust=-0.01,
vjust=-0.01),
strip.background=element_rect(fill='transparent',
color='transparent')) +
coord_fixed()
# display and save plots
if (display_plots) {
print(myplots[['q-vs-pairwise_bray-curtis']])
print(myplots[['q-vs-pairwise_other-metrics']])
print(myplots[['q-vs-pairwise_cohorts']])
}
if (save_plots) {
ggsave(file.path('.','plots','q-vs-pairwise_bray-curtis.pdf'),
plot=myplots[['q-vs-pairwise_bray-curtis']],
device='pdf',
height=120,
width=120,
units='mm')
ggsave(file.path('.','plots','q-vs-pairwise_other-metrics.pdf'),
plot=myplots[['q-vs-pairwise_other-metrics']],
device='pdf',
height=120,
width=240,
units='mm')
ggsave(file.path('.','plots','q-vs-pairwise_cohorts.pdf'),
plot=myplots[['q-vs-pairwise_cohorts']],
device='pdf',
height=180,
width=180,
units='mm')
}
